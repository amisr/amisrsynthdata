# create_synth_data.py
# Create an AMISR data file with synthetic data

from Field import Field
from Radar import Radar
import numpy as np
import datetime as dt
import pymap3d as pm
import h5py
import matplotlib.pyplot as plt

from argparse import ArgumentParser, RawDescriptionHelpFormatter

config_file_help = 'Some help string'

# Build the argument parser tree
parser = ArgumentParser(description=config_file_help,
                        formatter_class=RawDescriptionHelpFormatter)
arg = parser.add_argument('synth_config_file',help='Configuration file for synthetic data set.')
# arg = parser.add_argument('vvels_config_file',help='Vvels config file.')
args = vars(parser.parse_args())


# generate field object
field = Field(args['synth_config_file'])
# field.plot_ionosphere()

# generate radar object
radar = Radar(args['synth_config_file'])

print(radar.x.shape)

ne = field.density(radar.x, radar.y, radar.z)
te = field.etemp(radar.x, radar.y, radar.z)
ti = field.itemp(radar.x, radar.y, radar.z)
print('PARAMS', ne.shape, te.shape, ti.shape)

# fig = plt.figure(figsize=(10,10))
# ax = fig.add_subplot(111,projection='3d')
# c = ax.scatter(radar.X, radar.Y, radar.Z, c=ne)
# fig.colorbar(c)
# plt.show()


# # interpolate the field to the radar bin locations
# Vx = field.interpVx(np.array([radar.X, radar.Y, radar.Z]).T)
# Vy = field.interpVy(np.array([radar.X, radar.Y, radar.Z]).T)
# Vz = field.interpVz(np.array([radar.X, radar.Y, radar.Z]).T)
# Vvec = np.array([Vx, Vy, Vz]).T
# print(Vvec.shape)

Vvec = field.velocity(radar.x, radar.y, radar.z)
# print(Vvec)
#
#
# calculate LoS velocity for each bin by taking the dot product of the radar kvector and the interpolated field
# Vlos = np.tile(np.einsum('...i,...i->...',radar.kvec, Vvec), (len(self.times),1,1))
Vlos = np.einsum('...i,...i->...',radar.kvec, Vvec)
# assume constant error
dVlos = np.full(Vlos.shape, radar.vel_error)

print(Vlos.shape)

ne_nb = field.density(radar.x_nb, radar.y_nb, radar.z_nb)

# fig = plt.figure(figsize=(10,10))
# ax = fig.add_subplot(111,projection='3d')
# c = ax.scatter(radar.X, radar.Y, radar.Z, c=Vlos)
# fig.colorbar(c)
# plt.show()

# create unix time array
# Time array is 10 time steps (of integration period defined by the radar portion of the config file) after midnight
#   on January 1 of the year defined in the apex_year portion of the config file.  Because the field is defined manually
#   and not based on some empirical model, the time really doesn't matter and is mostly included to be consistent
#   with the read data file format.
time0 = (dt.datetime(field.apex_year,1,1)-dt.datetime.utcfromtimestamp(0)).total_seconds()
utime = np.array([[time0+t*radar.integration_period, time0+(t+1)*radar.integration_period] for t in range(10)])


# create fit and error arrays that match the shape of whats in the processed fitted files
# Fit Array: Nrecords x Nbeams x Nranges x Nions+1 x 4 (fraction, temperature, coll. freq., LoS speed)
s = (utime.shape[0],)+radar.x.shape
# fit_array = np.full(s+(6,4), np.nan)
fit_array = np.full(s+(2,4), np.nan)    # assume only O+
fit_array[:,:,:,0,1] = ti
fit_array[:,:,:,-1,1] = te
fit_array[:,:,:,0,3] = Vlos
fit_array[:,:,:,-1,3] = Vlos
fit_array[:,:,:,0,0] = np.ones(s)
fit_array[:,:,:,-1,0] = np.ones(s)

err_array = np.full(fit_array.shape,np.nan)
# err_array[:,:,:,0,3] = dVlos

dne = np.full(ne.shape, np.nan)

noise = np.full(s+(3,), np.nan)
# range0 = np.full(radar.x.shape, np.nan)  # SHOULD BE GENERATED BY RADAR CLASS
# range0_nb = np.full(radar.x_nb.shape, np.nan)  # SHOULD BE GENERATED BY RADAR CLASS

chi2 = np.full(s, 1.0)
dof = np.full(s, 26)
fitcode = np.full(s, 1)
nfev = np.full(s, 0)

ion_mass = np.array([16.])
print(fit_array.shape, chi2.shape, fitcode.shape)

snr = np.full(radar.x_nb.shape, np.nan)
dnefrac = np.full(ne_nb.shape, np.nan)
# # generate dummy density array
# self.ne = np.full(s, 1e11)

# create output hdf5 file
with h5py.File(radar.output_filename, mode='w') as h5:

    h5.create_dataset('BeamCodes', data=radar.beam_codes)

    h5.create_group('/FittedParams')
    h5.create_dataset('/FittedParams/Altitude', data=radar.alt)
    h5.create_dataset('/FittedParams/Errors', data=err_array)
    h5.create_dataset('/FittedParams/Fits', data=fit_array)
    h5.create_dataset('/FittedParams/IonMass', data=ion_mass)
    h5.create_dataset('/FittedParams/Ne', data=ne)
    h5.create_dataset('/FittedParams/Noise', data=noise)
    h5.create_dataset('/FittedParams/Range', data=radar.fit_slant_range)
    h5.create_dataset('/FittedParams/dNe', data=dne)

    h5.create_group('/FittedParams/FitInfo')
    h5.create_dataset('/FittedParams/FitInfo/chi2', data=chi2)
    h5.create_dataset('/FittedParams/FitInfo/dof', data=dof)
    h5.create_dataset('/FittedParams/FitInfo/fitcode', data=fitcode)
    h5.create_dataset('/FittedParams/FitInfo/nfev', data=nfev)

    h5.create_group('/Calibration')

    # need to call IGRF
    h5.create_group('/Geomag')
    h5.create_dataset('/Geomag/Latitude', data=radar.lat)
    h5.create_dataset('/Geomag/Longitude', data=radar.lon)
    h5.create_dataset('/Geomag/Altitude', data=radar.alt)
    h5.create_dataset('/Geomag/ke', data=radar.ke)
    h5.create_dataset('/Geomag/kn', data=radar.kn)
    h5.create_dataset('/Geomag/kz', data=radar.ku)

    # need to call MSIS-E
    h5.create_group('/MSIS')

    h5.create_group('/NeFromPower')
    h5.create_dataset('/NeFromPower/Altitude', data=radar.alt_nb)
    h5.create_dataset('/NeFromPower/Ne_Mod', data=ne_nb)
    h5.create_dataset('/NeFromPower/Ne_NoTr', data=ne_nb)
    h5.create_dataset('/NeFromPower/Range', data=radar.slant_range)
    h5.create_dataset('/NeFromPower/SNR', data=snr)
    h5.create_dataset('/NeFromPower/dNeFrac', data=dnefrac)

    h5.create_group('/ProcessingParams')

    h5.create_group('Site')
    h5.create_dataset('/Site/Latitude', data=radar.site_coords[0])
    h5.create_dataset('/Site/Longitude', data=radar.site_coords[1])
    h5.create_dataset('/Site/Altitude', data=radar.site_coords[2])
    h5.create_dataset('/Site/Code', data=0)
    h5.create_dataset('/Site/Name', data=radar.radar_name)
    h5.create_dataset('/Site/MagneticLatitude', data=radar.site_coords[0])
    h5.create_dataset('/Site/MagneticLongitude', data=radar.site_coords[1])
    h5.create_dataset('/Site/MagneticLocalTimeMidnight', data=radar.site_coords[2])

    # all these fields can be calclulated from time array
    h5.create_group('Time')
    h5.create_dataset('/Time/Day', data=utime)
    h5.create_dataset('/Time/MagneticLocalTimeSite', data=utime)
    h5.create_dataset('/Time/Month', data=utime)
    h5.create_dataset('/Time/UnixTime', data=utime)
    h5.create_dataset('/Time/Year', data=utime)
    h5.create_dataset('/Time/doy', data=utime)
    h5.create_dataset('/Time/dtime', data=utime)




print(radar.site_coords)
glat, glon, galt = np.meshgrid(np.arange(radar.site_coords[0],radar.site_coords[0]+10., 1.), np.arange(radar.site_coords[1]-20.,radar.site_coords[1]+20, 2.), np.arange(200., 500., 200.))

print(glat.shape, glon.shape, galt.shape)

x, y, z = pm.geodetic2ecef(glat, glon, galt*1000.)
ne0 = field.density(x, y, z)
te0 = field.etemp(x, y, z)
ti0 = field.itemp(x, y, z)
ve = field.velocity(x, y, z)
e, n, u = pm.uvw2enu(ve[:,:,:,0], ve[:,:,:,1], ve[:,:,:,2], glat, glon)

# scaling/rotation of vector to plot in cartopy
# https://github.com/SciTools/cartopy/issues/1179
es = e/np.cos(glat*np.pi/180.)
ns = n
sf = np.sqrt(e**2+n**2)/np.sqrt(es**2+ns**2)
e = es*sf
n = ns*sf

print(ne.shape, ve.shape)

import cartopy.crs as ccrs
import matplotlib.gridspec as gridspec

proj = ccrs.AzimuthalEquidistant(central_latitude=radar.site_coords[0], central_longitude=radar.site_coords[1])

fig = plt.figure(figsize=(12,6))
gs = gridspec.GridSpec(3,4)

for j in range(2):
    ax = fig.add_subplot(gs[j,0], projection=proj)
    ax.coastlines()
    ax.scatter(glon[:,:,j], glat[:,:,j], c=ne0[:,:,j], vmin=0., vmax=4e11, transform=ccrs.Geodetic())

    ax = fig.add_subplot(gs[j,1], projection=proj)
    ax.coastlines()
    ax.quiver(glon[:,:,j], glat[:,:,j], e[:,:,j], n[:,:,j], color='blue', transform=ccrs.PlateCarree())

    ax = fig.add_subplot(gs[j,2], projection=proj)
    ax.coastlines()
    ax.scatter(glon[:,:,j], glat[:,:,j], c=te0[:,:,j], vmin=0., vmax=5e3, transform=ccrs.Geodetic())

    ax = fig.add_subplot(gs[j,3], projection=proj)
    ax.coastlines()
    ax.scatter(glon[:,:,j], glat[:,:,j], c=ti0[:,:,j], vmin=0., vmax=3e3, transform=ccrs.Geodetic())

ax = fig.add_subplot(gs[-1,0], projection='3d')
ax.scatter(radar.x[np.isfinite(radar.x)], radar.y[np.isfinite(radar.x)], radar.z[np.isfinite(radar.x)], c=ne[np.isfinite(radar.x)], vmin=0., vmax=4e11)

ax = fig.add_subplot(gs[-1,1], projection='3d')
ax.scatter(radar.x[np.isfinite(radar.x)], radar.y[np.isfinite(radar.x)], radar.z[np.isfinite(radar.x)], c=Vlos[np.isfinite(radar.x)], vmin=-500., vmax=500.)

ax = fig.add_subplot(gs[-1,2], projection='3d')
ax.scatter(radar.x[np.isfinite(radar.x)], radar.y[np.isfinite(radar.x)], radar.z[np.isfinite(radar.x)], c=te[np.isfinite(radar.x)], vmin=0., vmax=5e3)

ax = fig.add_subplot(gs[-1,3], projection='3d')
ax.scatter(radar.x[np.isfinite(radar.x)], radar.y[np.isfinite(radar.x)], radar.z[np.isfinite(radar.x)], c=ti[np.isfinite(radar.x)], vmin=0., vmax=3e3)

plt.show()
